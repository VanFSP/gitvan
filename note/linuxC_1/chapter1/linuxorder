					linux命令及用法
linux系统根目录下的usr目录是Unix System Resource,即Unix系统资源的缩写
软件安装：
1. 源码安装
        安装流程：
	./configure：是为了检测目标安装平台的特征，并且检查依赖安装包是否可用或缺少，最终目的是生成Makefile
	make：若./configure没有报错，则编译源码包，编译后若没有报错，就生成可执行文件
	make install：将可执行文件放到指定目录并配置环境变量，允许我们在任何目录下使用这个软件
	一般装在/usr/local/目录下
2.RMP包安装
	装在默认位置
	默认位置是(常规并不是绝对)：
	/etc/init.d/  启动脚本位置
	/etc/sysconfig/ 初始化环境配置文件位置
	/etc/  配置文件
	/etc/xinetd.conf xinetd  配置文件
	/etc/xinetd.d/  基于xinetd服务的启动脚本
	/var/lib/  服务产生的数据放在这里
	/var/log/  日志
3.apt-get
	1. apt-get 指令管理安装包,自动从互联网的软件仓中搜索，安装，升级，卸载软件或操作系统
		1.apt-get install packagename
  		2.-y 不需要重复的确认安装
  		3.-q 静默安装，会将低级的log信息屏蔽
  		4.remove 仅仅卸载软件，并不卸载配置文件
  		5.purge 卸载指令，同时卸载相应的配置文件
  		6.autoremove 在卸载软件的时候同时卸载那些当初作为依赖但是现在并不需要的包
  		7.apt-get update 将所有包的来源更新
  		8.apt-get upgrade 一般用与第七条之后，将系统中旧版本的包升级成最新的
	2.apt-get 执行原理：
	在/etc/apt下有一个sources.list文件，是一些资源网站，软件包资源来自于这里， 第一步是reading package lists,即从sources.list中检索可用的源是否有这个软件包，第二步是生成软件依赖树，将需要的依赖包提前列出来，在安装所需软件之前进行安装。
	3.apt-get 可能遇到的问题：
	error:Could not get lock /var/lib/dpkg/lock - open
	error:Unable to lock the administration directory(/var/lib/dpkg/),is another process using it ?
	解决办法：
	原因是由于apt-get被占用，无法再次使用apt-get命令操作
		法一：在终端输入ps -ef|grep "apt-get",找出占用apt-get应用的进程，然后sudo kill -9 PID强制结束进程
		法二：若找不到占用的进程，可能是上一次安装操作的时候意外断电，没有正常退出导致的，此时强制删除以下两个文件：
	sudo rm /var/lib/dpkg/lock
	sudo rm /var/cache/apt/archives/lock
	这两个lock文件是系统在执行apt-get指令时若检测到不存在则会自动创建
	可以通过修改文件的锁属性的方式来解决这个问题，在文件inode结构体中有一个struct file_lock ×i_flock; 直接操作此结构体即可




gcc：GUN C Compiler (GUN C 编译器)
预处理 -> 编译 -> 汇编 -> 链接
预处理：gcc -E ：main.c -> main.i          命令：gcc -E main.c -o main.i    gcc调用预处理程序cpp，展开宏，插入#include包含的内容
编  译：gcc -S ：main.i -> main.s          命令：gcc -S main.i -o main.s    gcc调用编译器ccl，检查代码规范性以及是否具有语法错误等
汇  编：gcc -c ：main.s -> main.o          命令：gcc -c main.s -o main.o    gcc调用汇编器as ，将汇编代码生成目标文件(二进制代码)
链  接：gcc -o ：main.o -> main/main.out   命令：gcc -o main.o -o main/mian.out  gcc调用链接程序ld，ld将找库文件中所需要的函数并生成相对地址(地址/位置无关代码(PIC)),保存在可执行程序中，总的来说既是将目标文件与库函数链接成一个可执行程序

执行程序时是：运行程序时，若需要调用动态库，首先在内存中查看是否有该动态库的副本，若有，则共享该副本，若没有则调用ld-linux.so程序去查找该动态库并加载到程序(内存)中

1.-o：将输出文件放到<file>/指定输出文件文件名为<file>
2.gcc main.c ：不加任何参数，直接编译生成可执行文件
3.-D：宏定义选项，等同于代码中的#define 但-D定义的宏作用于所有的源文件
gcc -D PI=3.14159 main.c
4.-I：头文件的搜索路径：用户自定义头文件的搜索路径
gcc main.c -I /usr/include/  会在/usr/include/搜索main.c中所需要的头文件
5.-l：-llibrary 名为library的动态链接库，实际上在文件系统的的名字为liblibrary.so，连接器会自动加上lib*.so
6.-L：用户自定义库文件的搜索路径
7.-w：禁止所有警告信息  -Wall：打开所有警告选项，输出警告信息 -pedantic ：发现一些(非全部)不符合ANSI/ISO C标准的代码
8.-pipe：管道 加速编译过程 编译过程中会出现临时文件，读写临时文件是会消耗一定的时间的，小工程效果不明显
9.头文件一般存储在/usr/include的目录以及子目录，依赖与linux特定版本的头文件一般存储在/usr/include/x86_64-linux-gnu/sys和/usr/include/linux
10.库函数分静态库函数和动态库函数(共享库)
	静态库函数格式：libxxx.a	      程序运行时所需代码在编译时静态加载，即主程序文件以及其用到的库函数一起编译成目标文件，编译后的可执行文件可独立运行
	动态库函数格式：libxxx.so.major.minor 程序运行时所需代码在运行时动态加载,编译时只对动态库做语法检查
	xxx为该库函数的名称，major主版本号，minor副版本号
	标准系统库函数文件一般存储在/lib和/usr/lib
	gcc默认情况下优先使用动态库，若动态链接库不存在，才使用静态库
	归档为静态库：
	gcc -c main.c 
	ar crv/-r libmain.a main.o
	gcc main.c -L(+静态库目录） -static -o main
	-static 指强制使用静态库编译
	创建静态库：
	gcc -o libxxx.a -c xxx.c
	创建动态库：
	gcc -o libxxx.so -c xxx.c -fPIC -shared
11.静态库链接时搜索路径顺序：
	1.ld找gcc命令中的参数-L(用户指定的路径)
	2.再找gcc的环境变量LIBRARY_PATH
	3.再找默认目录/lib和/usr/lib和/usr/local/lib
	LIBRARY_PATH:程序静态链接库文件搜索路径
12.编译时查找动态库的顺序：
 	gcc写ld-linux.so到程序中的位置是可以由spec文件设定，即写完后ld-linux.so的位置就是固定的
	让gcc读spec文档中，即命令：echo'main(){}' | gcc -E -v - 
	1.找-L 指定库的位置
	2.找LD_LIBRARY_PATH/LIBRARY_PATH
	3.配置文件/etc/ld.so.conf中指定的路径
	4.再找默认目录/lib和/usr/lib
   编译时头文件的搜索路径顺序与动态库类似
	1.-I 指定头文件的目录
	2.在默认目录(内定目录)下查找：
	/usr/lib/gcc/x86_64-linux-gnu/8/include
	/usr/local/include
	/usr/lib/gcc/x86_64-linux-gnu/8/include-fixed
	/usr/include/x86_64-linux-gnu
	/usr/include
	这个默认目录在spec文档中，即命令：echo'main(){}' | gcc -E -v - 让gcc读spec文档
   运行时动态库链接时(即ld-linux.so加载动态库时的)搜索路径顺序：
	1.ld(ld-linux.so)找gcc命令中的参数-L(用户指定的路径)
	2.再找gcc的环境变量LD_LIBRARY_PATH
	3.配置文件/etc/ld.so.conf中指定的动态库搜索路径
	4.再找默认目录/lib和/usr/lib
	LD_LIBRARY_PATH:程序动态链接库文件搜索路径
   注：以上的顺序是在ld.so.conf.d目录下的文件有所改变后，并且sudo ldconfig更新ld.so.cache缓存文件后的正确寻找顺序
   注：只要ld.so.conf.d目录下的文件有所改变，最好(一定)更新ld.so.cache缓存文件

13.ldd xx 可以查看xx这个可执行程序依赖哪些库文件

ld:链接程序潜规则：
	1.当一个符号在多个目标文件(.o)里同时出现时，LD报错，提示符号重定义，
	2.当一个符号在多个景泰库里同时出现时，LD不报错，以遇到的第一个为准，并且不会有任何警告提示
	3.LD对库的依赖顺序敏感，当依赖库之间有依赖关系时，必须将依赖别人的库放在被别人依赖的库的前面，否则会链接失败
	4.当项目中包含多个同名的头文件时，会按照一定顺序在多个目录中挨个寻找，一旦找到一个即立即停止寻找，如果目录中包含多个同名的头文件，则以第一个为准，后面的直接忽略
	5.LD会把所有通过-l指定的动态库全部连接到最终的目标程序中，无论是否真的用到某个动态库，这回导致生产环境加载失败，即找不到动态库
	6.为什么会有未定义的符号？1.加载动态库时提示未定义符号导致加载失败，原因一：可能是由于符号所依赖的动态库的版本太低，没有包含指定的符号。原因二：假设我们确定符号在xxx.a/xxx.so中，有可能符号依赖的其他库中也用到了xxx.a/xxx.so，需要将xxx.a/xxx.so放到最后即可2.通过ldd -r 查看动态库，发现输出包含有未定义符号，但却仍可以正常加载，原因：即使有未定义符号，只要代码在执行过程中用不到，也能够正常加载，若是用到则会报错。即ld在链接生成动态库时，允许出现未定义的符号，因为这些符号可能在加载的时候就解决了。ld在链接生成可执行文件时，是不允许出现未定义符号的。

ld-linux.so:是专门寻找库文件的库。即负责加载动态库，它们读取可执行文件的头部信息来确定哪些库文件是必需的以及哪些需要加载，加载完成后，它会通过修正可执行文件里的相关的地址指针来和加载的库文件完成动态链接，此时程序就可以运行了。ld-linux.so在加载动态库的时候，会在ld.so.cache缓存文件中查找动态库，另外ld-linux.so也会查找LD_LIBRARY_PATH变量所指定的路径，但并不会将该路径更新到ld.so.cache缓存文件中。

ldconfig:是用来更新ld.so.cache缓存文件的命令，配合sudo使用
 
ld:负责将各个库文件的信息写进可执行文件中，这些信息是需要调用的函数在动态链接库中的相对位置

ldd xx 可以查看xx这个可执行程序依赖哪些库文件

ld.so.conf.d:可以在该目录下添加含有动态库目录的.conf配置文件或者在配置文件ld.so.conf中追加动态库目录

LD_LIBRARY_PATH:该变量尽量避免使用，若是需要测试/更新动态库，则最好使用该变量，防止将测试的动态库放到默认目录下或者配置文件下指定的搜索目录，使得系统重启时出现故障


环境变量：在操作系统中用来指定操作系统中的一些参数(当前环境下的变量或参数) 
env:查看所有的环境变量
环境变量PATH:当用户要求运行一个程序而没有告诉程序的完整路径时，系统除了在当目录下寻找此程序外，还要到PATH环境变量中指定的路径去寻找(决定了shell将到哪些目录中寻找命令或程序)
环境变量HOME：指的是当前用户的家目录
MAIL：是指当前用户的邮件存放的位置
HISTSIZE：是指保存历史命令记录的条数
LOGNAME：是指当前用户的登录名
HOSTNAME：是指主机的名称
LANG/LANGUGE：是和语言相关的环境变量
LD_LIBRARY_PATH:动态库的搜索路径
LIBRARY_PATH:静态库的搜索路径
对于重复定义的环境变量：后写入的先起作用
例如：第一个PATH=/usr/lib:/lib64 第二个PATH=/usr/local/lib
则系统认定的PATH=/usr/local/lib:/usr/lib:/lib64

系统及环境变量：每个登录到系统的用户都能够读到系统级的环境变量
		/etc/profile /etc/bashrc /etc/environment
用户及环境变量：每个登录到系统的用户只能读到属于自己的用户级的环境变量
		~/.profile ~/.bashrc ~/.bash_profile或~/.bash_login ~/.bashrc_logout
		若~/.bash_profile ~/.bash_login其中一个存在，则启动一个登录shell时，Bash会执行该文件而不执行~/.profile
		若都存在的话，优先执行~/.bash_pofile
		每次退出系统(退出bash shell)时执行~/.bashrc_logout
linux启动时环境变量的加载顺序：
	/etc/profile->/etc/profile.d/*.sh->~/.bash_profile|~/.bash_login|~/.profile->~/.bashrc->/etc/bashrc->~/.bash_logout

linux下配置环境变量常用的两种方法：
	1.修改家目录下的.bashrc文件(用户级别的环境变量，只针对特定用户)
	2.修改/etc/profile文件   (系统级别的环境变量，针对所有用户)
	profile文件在系统启动时将被运行
	可以在/etc/profile.d目录下创建shell(.sh)程序用来配置自己的环境变量
     均在文件的最后加入环境变量(加入下面两行)：
	变量名=变量值(注意等号两边没有空格)
	export 变量名
     或者加入下面一行：
	export 变量名=变量值
	3.最后通过重启系统(永久有效)或执行命令source .bashrc或/etc/profile(立即生效，只在当前shell中生效，退出shell将无效) 来生效
	source作用是在当前的bash环境下读取并执行filename中的命令，(相当于. filname .与filename之间有空格)，所有的环境变量都会保存在当前的shell中
	source的一个妙用：当反复输入一场串命令时，可以把这些命令做成一个文件，让它按顺序自动执行，source可以把这个文件的内容当成shell来执行
	sh filename 会创建一个子shell来执行程序，该子shell继承父shell的环境变量，但执行完后其子shell中中新建的，改变的环境变量不会被带回到父shell中，除非是用export
	./ filename 在当前目录下执行，与sh filename执行脚本没有区别

目录命令：
浏览目录：ls pwd
目录操作：cd mkdir rmdir
浏览文件：cat tac nl more less head tail
文件操作：cp rm mv find grep tar

pwd：print working directory 显示当前所在的目录
1.-P(大写的) 显示出确实的路径，而非使用连结(link)路径

绝对路径：由根目录起
相对路径：不是由根目录起

ls：list 显示目录文件
1.-a 查看所有文件，包含隐藏文件
2.-l 列出文件和目录详细信息
3.-d
4.-i 查看文件的节点号
5.-F 在文件名的后面加上符号
	* 表示可执行文件
	/ 表示目录
	@ 表示链接文件
	| 表示管道文件
	= 表示套节字文件
	> 表示进程间通讯设备


cd：change directory 改变/切换目录
1.cd /  2.cd ..(回到上一级目录) 3.cd ~ 回到主目录4.cd - 回到上一个目录

mkdir：make directory 创建新目录 mkdir directoryname
1.-v 为创建的目录打印一条信息
2.-p 递归的创建目录(创建多级目录)，如果目录已存在，则不产生错误
mkdir test1/test2/test3 -p
3.-m 设定文件权限，例如mkdir -m 777 hh 表示文件/目录hh可读，可写，可执行

rmdir：remove directory 删除空目录(非空不可以删除)
1.-p 连同上一级的目录(空的)也一起删除
rmdir test1/test2/test3 -p

cat：concatenate and display files 链接文件并打印到标准输出设备上
1.-E 在每一行的末尾显示$
2.-n 添加行号,空白行有行号
3.-b 添加行号，空白行没有行号
4.-T 将[tab]键以^|显示出来
5.-v 列出一些看不出来的特殊字符
6.cat filename / cat file1name file2name

tac：与cat相反，文件内容从最后一行显示

nl：显示行号
1.-b 指定行号指定的方式，有两种
   -b a:添加行号，空白行有行号
   -b t:添加行号，空白行没有行号
2.-n 列出行号表示的方法
   -n ln:行号在荧幕的最左方显示
   -n rn:行号在自己栏位的最右方显示，且不加0
   -m rz:行号在自己栏位的最右方显示，且加0
3.-w 行号栏位的占用的位数

more：分页显示文件内容
1.more filename 
2.(空格)或f显示下一页
3.(enter)显示下一行 
4.q 或Q退出
5.b 往回翻页，只对文件有效，对管线无效
6./字串 在显示的内容中向下搜寻字串这个关键字

less：与more类似less 区别在于可以使用上下键卷动文件
1./字串 向下搜寻字串
2.?字串 向上搜寻字串

head：用于显示文件前几行的内容
1.-n 显示前n行，不指定此参数显示前10行
tail：用于显示文件后几行的内容
1.-n 显示后n行，不指定此参数显示后10行
2.+n 从第n行显示到文件尾
3.-F 用于跟踪显示不断增长的文件结尾内容(通常用于显示日志文件)

cp：将一个文件/目录复制到另一处 copy
1.cp 参数 源文件路径 目标文件路径
2.-p 连同文件的属性一起复制，而非使用默认方式，常用于备份
3.-i 若目标文件已经存在时，在覆盖时会先询问操作的进行
4.-r 递归持续复制，用于目录的复制行为
5.-u 目标文件与源文件有差异时才会复制

rm：删除目录/文件(remove)
1.rm 参数 目标文件路径
2.-f (force) 忽略不存在文件，不会出现警告消息，强迫删除
3.-i 互动模式，删除前询问用户是否操作(使用Y或N表示允许或拒绝删除)
4.-r 递归删除，常用于目录删除，删除该目录下所有文件以及子目录
5.* 删除当前目录下所有文件

mv：移动文件/目录(move)/修改名称
1.mv 参数 源文件 目标文件
2.可以重命名 mv file test 将名为file的文件重命名为test
3.将文件移动到某个目录下 mv file test /home/gideon/ 将file文件和test文件移动到目录/home/gideon/下
4.-f 覆盖前不询问
5.-i 覆盖前询问
6.-n 不覆盖已存在的文件
若参数指定了-f -i -n中的多个，则仅最后一个生效
7.-t 将多个文件移动到某个目录下，此时目录路径在前 mv -t /home/gideon file tset

find：用来寻找文件或目录
1.find 路径 参数
2.-name filename：找出文件名为filename的文件
3.-size[+-]SIZE：找出比SIZE还要大或小的文件
4.-type TYPE：查找文件的类型为TYPE的文件，TYPE的值主要有：一般文件(f)，设备文件(b或c)，目录(d)，链接文件(l)，socket(s)，FIFO管道文件(p)
5.-perm mode：查找文件权限刚好等于mode的文件，mode用数字表示

grep：在文件中搜索匹配的字符并出输出该字符串所在行
1.grep 参数 要找的字串 要找字串的源文件
2.-a：将binary文件以text文件的方式查找数据 
3.-i：忽略大小写的区别
4.-v：反向选择，显示出不包含‘查找字符串’内容的一行
5.-c：计算找到‘查找字符串’的次数


tar：能够将用户所指定的文件或目录打包成一个文件，也可以通过指定参数开启压缩/解压功能
1.-c 新建打包文件
2.-t 查看打包文件的内容含有那些文件名
3.-x 解打包或解压缩的功能，可以搭配-C指定解压的目录，注意-c,-t,-x不能同时出现在同一个命令中
4.-j 通过bzip2的支持进行压缩/解压缩
5.-z 通过gzipd的支持进行压缩/解压缩
6.-v 在压缩/解压缩过程中，将正在处理的文件名显示出来
7.-f filename filename为要处理的文件
8.-C dir 指定压缩/解用压缩的目录dir


进程命令
查看系统中的进程：ps top
控制系统中的进程：kill killall nice renice
进程后台运行：&
进程的挂起和恢复：
挂起(Ctrl+Z) 终止(Ctrl+C)
进程恢复：
1.恢复到前台继续运行(fg) fg[n]
2.恢复到后台继续运行(bg) bg[n]
查看被挂起的进程(jobs)

ps：显示系统瞬间的进程信息，可以显示出在用户输入ps命令时系统的进程以及进程的相关信息
1.ps 参数
2.l 长格式输出
3.u 按用户名和启动时间的顺序来显示进程
4.j 用任务格式来显示进程
5.f 用树形格式来显示进程
6.a 显示所有用户的所有进程(包括其他用户)
7.x 显示无控制终端的进程
8.r 显示运行中的进程

top：动态监视系统任务的工具(任务管理器) 输出结果是连续的
1.top 参数
2.-b 
3.-c
4.-d
5.-i
6.-n
7.-p 
8.-q
9.-s
10.-S

kill：

killall：

nice：

renice：
---------------------------------------------------------------------------------------
linux 小常识：
---------------------------------------------------------------------------------------

用户名@主机名

用户及权限管理类命令：
用户管理类命令：useradd usermod passwd userdel su id whoami w finger
用户组管理类命令：groupadd groupmod groupdel 
文件权限管理类命令：chmod chown chgrp stat file

linux用户分三类：
1.超级用户：拥有最高权限(即root用户)
2.系统用户：与系统服务相关，但不能用于登录
3.普通用户：由超级用户创建并赋予权限，只能操作其拥有权限的文件和目录，只能管理自己启动的进程

用户信息：
1.用户名：唯一，由字母，数字和符号组成
2.口名(密码)
3.用户ID(uid)：每个用户拥有的惟一的识别号码，超级用户为0,系统用户1-499,普通用户的500开始
4.用户组ID(gid)
5.用户主目录
6.全程：用户账户的附加信息，可以为空
7.登录Shell：默认是用Bash

×××用户帐号信息文件/etc/passwd
1.文件每一行都是一个用户的信息
2.文件各字段从左到右依次为：用户名，口令，用户ID，用户组，全称，用户主目录和登陆Shell
3.口令字段用x来填充，加密后的口令保存在/etc/shadow文件中
×××用户口令信息文件/etc/shadow
1.shadow文件只有超级用户可以查看并修改器内容，而且加密存储

用户组：相同特性的用户的集合，包括系统用户组和私人用户组
用户组优点：简化用户管理，方便用户之间共享文件
一个用户只能属于一个用户组(基本组)，但可以同时属于多个附加组
用户不仅拥有用户组(基本组)的权限，还同时拥有附加组的权限
×××用户组帐号信息文件/etc/group
1.每一行为一个用户组信息
2.文件中各字段从左到右以此为：用户组名，口令，用户组ID和附加用户列表
×××用户组口令信息文件/etc/gshadow
×××用户个人文件：主目录默认位于/home/用户名
×××用户邮箱文件：默认位于/var/spod/mail/用户名

×××创建用户时依照/etc/login.def 和/etc/default/useradd (创建用户的默认设置文件)进行创建的 


----------------------------------------------------------------------------------------
useradd：新建用户帐号(超级用户可用)
1.useradd 参数 用户名
2.-d 指定用户登入时的主目录     useradd -d homedir username
3.-s 指定账户登录后所使用的shell
4.-e 账户终止日期
5.-u 指定用户ID                 useradd -u id
6.-G 指定账户所属的附加组       useradd -G groupname username
7.-g 指定账户所属的用户组       useradd -g groupname username

passwd ：设置或修改用户的口令以及口令属性
1.更改用户密码                  passwd/passwd username

usermod：修改用户属性
usermod 参数 用户名
1.-u 用户账户的新UID	        usermod -u newuid olduid
2.-l 新的登录名                 usermod -l newname oldname
3.-d 用户的新主目录             usermod -d  newhomedir  username
4.-m 将家目录内容移至新位置(仅与-d 一起使用) 
                                usermod -m -d newhomedir username
5.-s：该用户帐号的新登录 shell
6.-L：临时锁定用户              usermod -L username
7.-U：解锁用户                  usermod -U username
8.-G：将已有用户加到已有用户组中usermod -G groupname username
9.-g：将已有用户加到已有用户组中同时将其主要用户组更改为加入的已有用户组
                                usermod -g groupname username
10.-c：修改用户的全称(名)       usermod -c newnickname userame

userdel：删除指定的用户帐号
usermdel 参数 用户名
1.-f 即使不属于此用户，也强制删除文件
2.-h 显示此帮助信息并退出 
3.-r 删除主目录和邮件池
4.-R chroot到的目录 
5.-Z 为用户删除所有的SELinux用户映射

su：切换用户身份
1.su 用户名
2.超级用户可以切换为任何普通用户且不需要口令，普通用户切换为其他用户时需要输入被切换用户的口令
3.使用exit可以返回到本来的用户身份
4.su root 是切换到超级用户，但是依然保持旧的环境，而su - root不仅是切换到超级用户，而且创建了一个新的环境

sudo：让普通用户执行一些或者全部的root命令的一个工具，是面向每一个命令的,(即提升用户权限)
1.需要输入当前用户的密码，回答系统即会将命令的进程以超级用户的权限运行，之后的一段时间内(默认为5分钟)使用sudo不需要再次输入密码
2.配置文件是sudoers文件，默认位置/etc/sudoers,它允许系统管理员集中的管理用户的使用权限和使用的主机
3.检测安装：rpm -q sudo
4.sudo -v 可以查看该用户是否可以使用sudo命令
5.sudo su root /sudo 命令(需要提升权限的命令)

----------------------------------------------------------------------------------------
linux 小常识
----------------------------------------------------------------------------------------
sudoers配置文件信息：
root ALL=(ALL:ALL) ALL
第一段：用户名或者用户组，表示谁有权限来使用后面的配置  root
第二段：表示来源地，即从哪执行这条命令                  ALL
第三段：表示用户					ALL
第四段：表示用户组					ALL
第五段：表示命令					ALL
echo "用户名(例如test) ALL=(ALL:ALL) NOPASSWD:ALL" >> /etc/sudoers
test可以免密执行sudo的所有命令

real user id：
effective user id：
saved user id：
ID:：身份证标识号
----------------------------------------------------------------------------------------

id：查看用户的UID，GID和用户所属用户组的信息，若不指定用户，则显示当前用户的相关信息
1.id 用户名
2.-a 忽略，以便于其他版本兼容
3.-g 打印有效组的ID
4.-G 打印所有组的ID
5.-u 只打印有效的用户ID
6.-r 打印真正的ID来代替有效的ID
7.-n 打印名字来代替数

whoami：显示与当前的有效用户ID相关联的用户名
1.相当于id -un

w：查看当前登陆系统用户和详细信息

groupadd：新建组群(超级用户可用)
1.groupadd 参数 用户组名
2.-g 指定用户组ID
3.-o 允许组ID号不唯一

groupmod：修改指定用户组的属性(超级用户可用)
1.group 参数 用户名
2.-g：指定新的用户组ID
3.-n：指定新的用户组名字
4.-o：允许组ID号不唯一

gpasswd ：
1.-d 从组group中删除或添加用户 gpasswd -d username groupname
保证group不是用户的主组(用户组/基本组)


groupdel：删除指定用户组(超级用户可用)
1.group 用户组名
2.删除之前必须保证该用户组不是任何用户的主要组群，否则要先删除依次用户组为主要族群的用户才可以删除该用户组

----------------------------------------------------------------------------------------
linux 小常识
----------------------------------------------------------------------------------------
文件/目录权限：读取，写入，执行
读取权限：浏览文件或目录中的内容的权限
写入权限：
1.修改文件内容权限
2.删除，添加和重命名目录内文件的权限
执行权限：
1.允许执行的权限
2.进入目录的权限

文件权限分别是用三个数字代表(ABC),分表代表用户，组，其他用户的权限，若是每个数字转换成由‘0’或‘1’组成的二进制数，则每一位代表一个角色的读，写执行权限，例如用户的权限：若是可读，可写，可执行，则表示为二进制的111,即十进制为7,为不同的角色分配不同的权限放在一起即出现类似777,677这种数字，777,第一个7代表用户的权限为读，写，执行，第二个代表组的权限，第三个代表其他用户的权限


文件用户的分类：
文件分类：
(-)普通文件：(数据文件)长期存储在磁盘，又分为文本文件和二进制文件
(d)目录文件：包含其他文件的名字以及指向这些文件有关信息的指针
(b)块设备文件：提供对设备带缓冲的访问
(c)字符设备文件：提供对设备不带缓冲的文件
设备文件存放在/dev目录中
(l)链接文件(符号链接)：类似windows下的快捷方式，使文件指向另一个文件
(p)管道(FIFO)文件：主要作用于在进程间传递数据的一种特殊文件
(s)套字节文件：主要用于不同计算机间网络通信的一种特殊文件

544365 -rw-r--r-- 1 root root 3 Jan 28 20:00 /usr/include
索引节点编号：544365
文件类型：- 普通文件
文件权限：rw- 该用户的权限为读写，r--该用户组中的其他用户可读，r--非该用户组下的用户可读
硬链接个数：1个
文件所属用户：root用户
文件所属用户组：root用户组
文件大小：3字节,单位为字节(B)
文件最近修改日期：Jan 28 20：00
文件目录：/usr/include

----------------------------------------------------------------------------------------

chmod：修改文件访问权限
1.chmod 模式 文件  模式可为数字或者u+r这种形式
2.u 文件所有者 g 同组用户 o 其他用户
3.+ 增加 - 删除 = 赋予
4.r 读 w 写 x 执行 s 设置用户ID


chown：将指定文件的拥有者改为指定的用户或用户组
1.chown 选项 所有者/组 文件

chgrp：修改文件的所属用户组
1.chgrp 选项 组 文件

vim 中的操作：

复制删除：
yy：单行复制
nyy：从光标向下复制n行
p：将已复制的数据数据粘贴到光标下一行
P：将已复制的数据粘贴到光标下一行
dd：删除一行
ndd:从光标向下删除n行
x：删除当前字符

跳转：
跳到指定(22)行：22+G或esc后输入：22
跳到最后一行：G或shift+g
跳到第一行：gg

撤销：
u：撤销上一个操作
ctrl+r：多次撤销
.：小数点键，重复上一个操作

命令行模式：
:w   ：保存文件
:w!  ：若文件为只读，强制保存
:q   ：离开vim
:q!  ：不保存，强制离开
:wq  ：保存后离开
:wq! ：强制保存后离开
:set nu/number     ：显示行号
:set nonu/nonumber ：取消行号
:w newfile ：另存为

缩进：
esc后输入:行号1,行号2>：将行号1 到行号2 缩进一个tab值
esc后输入:行号1,行号2<：将行号1 到行号2 缩回来一个tab值

磁盘管理常用命令：df du mount fdisk mkfs

df:列出文件系统的整体磁盘占用情况
1.-a 列出所有文件系统，包括系统特有的/proc等文件系统
2.-k 以KB的容量显示个文件系统
3.-m 以MB的容量显示个文件系统
4.-h 以人们较易阅读的格式显示
5.-T 显示文件系统类型
6.-i 不用硬盘容量，而以inode的数量表示

du:统计目录或文件所占磁盘空间大小的命令
1.-a 列出所有的文件与目录容量，默认仅统计每个目录所占磁盘空间大小而已
2.-h 以人们较易读的容量格式显示
3.-s 列出总量而已，而不列出每个个别的占用容量
4.-S 不包括子目录下的总计
5.-k 以KB列出容量显示
6.-m 以MB列出容量显示

mount：挂载文件系统(磁盘挂载)  mount 选项  装置名 挂载点
1.挂载：指的是就是设备文件中的顶级目录连接到linux跟目录下的某一目录(最好是空目录)，访问此目录就等同于访问设备文件，注意，并不是根目录下的任何一个目录都可以作为挂载点，挂载点最好是新建的空目录
2.mount 显示出系统中已挂载的设备信息，注意有虚拟文件系统，使用-l选项，会额外显示出标卷的名称
3.mount -a 选项-a含义是检查/etc/fstab文件中有无疏漏被挂载的设备文件，若有，进行自动挂载操作，/etc/fstab文件是自动挂载文件，开机时会自动读取/etc/fstab这个文件中的内容，根据文件的配置，系统会自动挂载指定设备
4.-t 系统类型：指定欲挂载的文件系统类型 Linux常见的支持类型有ext2,ext3,ext4,iso9660(光盘格式)，vfat,reiserfs等，若不指定类型，挂载时会自动检测
5.-L 卷标名：除了是用设备名之外，还可以使用文件系统的卷名称进行挂载
6.-n 在默认下，系统会将实际挂载的情况实时写入/etc/mtab文件中，但未避免出现问题，可使用该选项刻意不写入
7.-o 特殊选项：可以指定挂载的额外选项，比如读写权限，同步异步等，若不指定，则使用默认值
8.mount/unmount 源于UNIX，UNIX一般作为服务器使用，系统安全非常重要，有效的方法是不使用的硬盘分区不挂载，因为不挂载意味着该分区无法访问，这样系统更加安全，同样也可减少挂载的硬盘分区数量，相应地，也就可以减少系统维护文件的规模，当然减少了系统的开销，提高了系统的效率

unmount:磁盘卸载命令 unmount 选项 装置文件名或挂载点
1.-f 强制卸除！可用在类似网络文件无法读取到的情况下 
2.-n 不升级/etc/mtab情况下卸除
3.像U盘插入就是挂载(mount)(或自动挂载)到目录下，U盘弹出就是卸载U盘即unmount

fdisk:用于磁盘分区
1.-l 后面要加装置名称 若仅有fdisk -l 系统将会把整个系统内能搜寻到的装置的分区均列出来
2.fdisk 磁盘文件名 可以查看硬盘内的相关信息

mkfs:磁盘格式化
1.-t 可接文件系统格式，例如ext2,ext3,ext4,vfat(系统有支持才生效)
eg. mkfs -t ext4 /dev/sda9 将此分区格式化为ext4文件系统
2.mkfs [tab][tab] 可查看mkfs支持的文件系统格式

fsck:用来检查和维护不一致的文件系统
1.fsck [tab][tab] 查看系统中有多少文件系统支持fsck操作
2.-t 给定档案系统的型式，若在/etc/fstab中有定义或kernel本身已支援的则不需加
3.-C 显示出完整的检查进度
4.-V 详细显示模式
5.-f 若文件系统不曾出现问题，若不加-f则检查的非常快速，若加上-f才会强制检查，一项一项的显示过程
6.-a 若检查有错则自动修复
7.-r 若检查有错则由使用者回答是否修复

stat:查看inode(索引节点)信息
1.stat 文件名 查看该文件的inode
2.inode中的信息有:
	文件名 
	文件大小	文件数据所占块数IO块	文件类型 
	设备		节点号		硬链接
	权限		用户id		組id
	最近访问
	最近更改
	最近改动
	创建时间
3.具体文件系统的索引节点是存储在磁盘上的，是一种静态结构，要使用它，必须调入内存，填写VFS的索引节点，因此，VFS索引节点也是动态节点
4.stat结构体中的成员st_size表示文件的长度，该字段仅对(-),(d),(l)这三个文件有意义，其中对于(-)，则表示文件的大小(读文件时，将得到文件结束指示)，对与(d)，则通常为一个常数，例如16或512的整数倍，对于(l),则表示路径名的长度(文件名中的实际长度)，例如一个符号链接文件 t->usr/hello.c ,则st_size=11 

file:辨识文件类型
1.-v 显示版本信息
2.-b 列出辨识结果，不显示文件名称
3.-c 详细显示指令执行过程，便于排错或分析程序执行的情形

uname:
uname -a :打印系统信息,包括计算机型号，操作系统名称，版本，发行号，计算机网络名

umask:指定在建立文件时预设的权限掩码 (权限掩码是由3个八进制的数字所组成)
-S：以文字的方式来表示权限掩码
使用该命令可查看当前的权限掩码


od:八进制输出文件内容
ctrl + d:表示文件尾标志
od -c 文件名:八进制输出文件的内容

runlevel:查看当前运行在哪一级别
init: init number 进入number级别 number={0,1,2,3,4,5,6}
运行级别：
要进入3级别，则将/etc/rc3.d/目录下的以S开头的脚本文件运行一下
要退出3级别，则将/etc/rc3.d/目录下的以K开头的脚本文件运行一下	


linux服务：
	1.RPM包默认安装的服务
		1.独立的服务
		2.基于xinetd的服务(不占内存)，这种服务越来越少
	RMP包的默认安装位置是(常规并不是绝对)：
	/etc/init.d/  启动脚本位置
	/etc/sysconfig/ 初始化环境配置文件位置
	/etc/  配置文件
	/etc/xinetd.conf xinetd  配置文件
	/etc/xinetd.d/  基于xinetd服务的启动脚本
	/var/lib/  服务产生的数据放在这里
	/var/log/  日志
	2.源码包安装的服务
	源码包的服务一般位于/usr/local/下

RPM包服务管理如下：
chkconfig --list :查看RMP包安装的服务，以及服务的自启动(注意：表示该服务在下一次开机将启动或关闭服务，而此时是否启动或关闭并不清楚)状态
chkconfig --level 2345 服务名 on/off : 表示下次开机在级别为2345上启动或关闭该服务
但是对于基于xinetd的服务，以上代码会将自启动和启动相通，即启动与自启动都开启/关闭

netstat:查看系统中已经启动的服务
服务的端口号可以通过/etc/services文件查看

独立服务的启动的方式
1.标准的方法：/etc/init.d/独立服务名  |start|stop|status|restart|
2.redhat专有的方式：service 独立服务名      |start|stop|status|restart|
service 的搜索路径是/etc/init.d/目录下的服务

独立服务的自启动的方式
1.标准的方法：chkconfig [--level 运行级别] [独立服务名]  [on/off]
#条件表达式要放在放括号内并且之间要有空格 eg. [ $a == $b ]
2.修改/etc/rc.d/rc.local文件
3.redhat专有的：ntsysv命令管理自启动

源码包服务的启动方式：
1.使用绝对路径，调用启动脚本来启动(不同的源码包的启动脚本不同，可查看安装说明)
	绝对路径  start|stop
源码包服务的自启动方式：
1.手动将" 绝对路径 start|stop " 写如/etc/rc.d/rc.local文件
2.让源码包的服务能被service命令识别
	即建立符号链接 ln -s 绝对路径 /etc/init.d/
3.让源码包服务能被chkconfig命令识别
	即首先建立符号链接 ln -s 绝对路径 /etc/init.d/
	然后vim /etc/init.d/服务名  将以下两行代码加入该文件中
	# chkconfig:运行级别 启动顺序 关闭顺序
	# description:source package 服务名
	启动顺序：是一个整数，不能与rc
	关闭顺序：是一个整数



wc:用于计算字数
1.c 显示字节数
2.l 显示行数
3.w 显示字数
4.默认下 wc filename 依次显示行数，字(单词)数，字节数

查看目录下有多少个文件：ls -l | grep "^-" | wc -l
查看目录下有多少目录文件：ls -l | grep "^d" | wc -l
查看目录下有多少个文件(包含子目录下的文件)：ls -l | grep "^-" | wc -l
	

read:用于从标准输入(使用重定向时，可读取文件中的一行)读取数值
1.-a 后面跟一个变量，该变量被认为是个数组，然后给其赋值，默认以空格隔开
2.-p 后面跟提示信息，在输入前打印提示信息
3.-s 安静模式，在输入字符时不再屏幕上显示
4.-t 后面跟秒数，定义输入字符的等待时间 超时未输入，read返回一个非零退出状态
5.-n 后面跟一个数字，定义输入文本的长度，当到达该长度时，read会立即接受输入并将其传给变量，无需按回车键
6.-e 在输入时可以使用命令补全功能，输入后按下Tab键会输入相关的数据
7.-r 屏蔽\，若无该选项，则\作为一个转义字符，有的话，\是个正常字符
8.-u 后面跟fd,从文件描述符中读入，fd可以是exec新开启的

expr:手工命令行计数器，用于在UNIX/LINUX下求表达式变量的值，一般用于整数值，也可用于字符串
1.表达式说明：
	用空格隔开每个项(若不加空格则输入其本身)
	用\放在shell特定的字符中
	对包含空格和其他特殊字符的字符串要用引号括起来
2.计算字串长度：expr length 字符串
3.抓取字串：expr substr 字符串 起始位置 抓取长度 (字符串中从1开始算而非0)
4.抓取第一个字符出现在字符串中的位置：expr index 字符串 字符
5.整数运算：
	expr 14 % 9
	expr 10 + 10
	expr 10 - 5
	expr 10 \* 10(使用乘号时，必须用反斜线屏蔽其特定含义，shell中可能被误解为星号)
	expr 30 / 10

&&:命令链接符，链接两个命令，前者成功执行后，后者才能执行 可使用echo $? 来判断上一条命令是否成功

&：命令后面跟一个&，表示该命令被放在后台执行








