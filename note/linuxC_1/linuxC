				chapter four:多文件编译
1.例如有多个源文件(test_1.c test_2.c test_3.c test_4.c main.c)，多头文件(test_1.h test_2.h test_3.h test_4.h)，主函数在main.c源文件中,则编译时需如下编译：
gcc -c test_1.c -o test_1.o
gcc -c test_2.c -o test_2.o
gcc -c test_3.c -o test_3.o
gcc -c test_4.c -o test_4.o
gcc -c main.c   -o main.o
gcc mian.o test_1.o test_2.o test_3.o test_4.o -o main

				chapter five:MakeFile文件的编写和使用(make_file)
1.make -v 查看版本 若没有安装make 则apt-get install make 安装
2.make是linux系统中一个非常重要的编译命令 
3.makefile文件定义来文件的编译规则，即”自动化编译“
4.make的工作原理：
	make命令被执行时，它会扫描当前目录下Makefile或makefile文件找到目标以及其依赖。如果这些依赖自身也是目标，继续为这些依赖扫描Makefile建立其依赖关系，然后编译它们。主依赖编译后就编译主目标。若对某个源文件进行了修改，再次执行make命令时，它将只编译与该源文件相关的目标文件，即节省时间。
5.make命令执行后有三个退出码：
	0表示成功执行 
	1表示make运行时出现任何错误，其返回为1 
	2表示如果你使用了make的“-q”选项，并且make使得一些目标不需要更新，则返回2
6.GNU make找默认的Makefile的规则是在当前目录下依次找三个文件："GNUmakefile","makefile","Makefile",一旦找到，便开始读取该文件并执行。也可以制定一个特殊的名字，使用参数“-f”或“--file”或"--makefile",eg. make -f test.mk (makefile 的名字是test.mk)



				chapter six : main函数详解(main.c)
1.int main(int argv,char*argc[])
  {
      return 0;
  }
argv表示系统接收的参数的个数，argc[i]代表每个参数的值 (i=0,1,2....)
其中return 0;代表main函数执行后返回给操作系统的值为0，在linux中返回给操作系统的值若为0(零)，则代表该命令成功执行
eg. cc main.c -o main
	./main 此时执行可执行文件main，argv的值为1，操作系统接收了1个参数，且argc[0]=0
	./main a b c d 此时执行可执行文件main，argv的值为5,操作系统接受了5个参数，
	且argc[0]=0,argc[1]=a,argc[2]=b,argc[3]=c,argc[4]=d  操作系统可以根据后面的参数		来做出相应的的反应(若有)

2.&&：命令链接符号，前者命令执行成功后才会执行后者命令，命令的成功执行会给操作系统返回一个为0的值，也可以通过echo $? 来判断上一条命令是否成功执行


				chapter seven:标准输入输出流错误流(stdin_out_err)和管道
1.stdin:输入流 键盘文件，从键盘上读取数据，即读文件        键盘输入
2.stdout:输出流 屏幕文件，向屏幕上显示(写入)数据，即写文件 终端输出
3.stderr:错误流                                            错误输出
4.重定向：<</< 输入流重定向  >>/> 输出流重定向   符号两侧没有空格
	./main 1>>/>data_out.txt 将标准输出流写入文件data_out.txt中
	./main 0<(不可以写成<<)data_in.txt 将data_in.txt作为输入流读到标准输入流中
	./main 2>>/>fail.txt 将标准错误流写入文件fail.txt中
	1 0 2  可以省略，都需要时不能省略，若省略>>前的1或2,则默认为1,即输出流
	>>/<<表示不会覆盖原有的内容,在下一行写入追加的内容 (输出输入追加重定向)
	>/<表示可以覆盖原有的内容 (输出输入重定向)
	正确形式：./main 0(可省略)<infile  1>>/>outfile 2>>/>errorfile
	若写成：>>infile >>outfile 则默认为将输出流写进文件outfile中，错误流输出到终端屏幕

5.|：表示管道， A|B 表示将命令A的输出流作为命令B的输入流，即将两个程序结合起来使用
			
				chapter eight:gdb 使用方法
1.安装gdb：apt-get install gdb  
2.调试程序：gdb ./main，gcc 添加-g 选项时，才可以调试，调试下输入：
	list/ls/l 表示列出当前项目的源代码
	[enter]表示继续显示当前项目的源代码
	break 12 表示在第12行设置断点，默认断点在main函数中的第一行代码
	start 表示开始调试
	(之所以可以调试，是因为源代码的机器码被加载到了内存(代码段)中)
	n 表示显示要将执行的一行代码，同时表示上一行代码已经执行
	s 表示进入子函数
	f 1 表示回到栈1中的函数
	bt 表示查看函数堆栈
	p 表示打印后面变量的值
	x/3d 地址a 表示从地址a开始以十进制的方式输出三个数据
	q 表示退出调试
	 
				chapter nine:指针与内存
1.主存储器通过数据总线，地址总线和控制总线与CPU链接
	数据总线的位数与工作频率的乘积正比与数据传输率
	地址总线的位数决定了可寻址的最大内存空间
	控制总线(读/写)指出总线周期的类型和本次输入/输出操作完成的时刻
2.理论上计算机可管理的内存空间：
	32位 内存空间为2^32=4GB 64位 内存空间为2^64
	1B(字节)=8b 1KB(千字节)=2^10B=1024B 1MB(兆字节简称“兆”)=2^10KB=1024KB
	1GB(吉字节又称“千兆”)=2^10MB=1024MB 1TB(万亿字节 太字节)=2^10GB=1024GB
	1PB(千万亿字节 拍字节)=2^10TB=1024TB 1EB(百亿亿字节 艾字节)=2^10PB=1024PB
	1ZB(十万亿亿字节 泽字节)=2^10EB=1024EB 1YB(一亿亿亿字节 尧字节)=2^10ZB=1024ZB
	1BB(一千亿亿亿字节)=2^10YB=1024YB 1NB(Nona byte)=1024BB 1DB(Dogga byte)=1024NB
3.操作系统会对所有内存进行编号
	编号 = 惟一的内存字节的地址(1字节可以存放8个二进制位的数据)
	eg.64位操作系统内存地址编号
		二进制表示：0000 0000 …… 0000 0000
		二进制表示：1111 1111 …… 1111 1111
4.操作系统对内存进行划分
	高16位为操作系统的内核地址，是操作系统来使用的 称为内核态
	低48位为用户使用的地址，由低到高又分为代码段，数据段，堆，自由可分配内存和栈 称为用户态
	代码段：源代码编译后的二进制数据存放的位置
	(源代码存放在磁盘上，源代码编译后的二进制数据会加载到内存中去运行)
	数据段：全局变量，变量，常量的存放位置(变量，常量本质就是地址，它只是一个代号)
	操作系统会将相同类型的变量放在一起即地址是紧挨着的
	堆：最先压入栈的地址最大，是向下分配地址的
	自由可分配内存：用于用户应用程序动态分配
	栈：记录/保存程序运行状态的全过程

